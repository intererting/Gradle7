import javax.inject.Inject

plugins {
    id 'com.android.application'
    id 'kotlin-android'
}

android {
    compileSdk libs.versions.compileSdk.get().toInteger()

    defaultConfig {
        applicationId "com.yly.mvvmlist"
        minSdk 21
        targetSdk libs.versions.targetSdk.get().toInteger()
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"

        //A library dependency includes a flavor dimension that your app does not.
        //For example, a library dependency includes flavors for a "minApi" dimension, but your app includes flavors for only the "tier" dimension. So, when you want to build the "freeDebug" version of your app,
        // the plugin doesn't know whether to use the "minApi23Debug" or "minApi18Debug" version of the dependency.
//        missingDimensionStrategy 'debug', 'release'
    }

    signingConfigs {
//        release {
//            storeFile file("myreleasekey.keystore")
//            storePassword "password"
//            keyAlias "MyReleaseKey"
//            keyPassword "password"
//        }
    }

//    lint {
//        it.abortOnError = false
//        it.checkDependencies = true
//    }

    flavorDimensions = ["version"]

    //build.gradle
    productFlavors {
        apple {
            dimension "version"
            manifestPlaceholders = [flavorName: "Apple"]
        }
        banana {
            dimension "version"
            manifestPlaceholders = [flavorName: "Banana"]
        }
    }

    buildTypes {
        release {
//            signingConfig signingConfigs.release
//            applicationIdSuffix ".debugStaging"
//            versionNameSuffix "-full"
//            versionCode 20
            manifestPlaceholders = [buildTypeName: "release"]
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
        staging {
            //Your app includes a build type that a library dependency does not.
            //1：For example, your app includes a "staging" build type, but a dependency includes only a "debug" and "release" build type.
            //2：For a given flavor dimension that exists in both the app and its library dependency, your app includes flavors that the library does not.
            matchingFallbacks = ['debug', 'release']
            manifestPlaceholders = [buildTypeName: "staging"]
        }

        debug {
            manifestPlaceholders = [buildTypeName: "debug"]
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_11
        targetCompatibility JavaVersion.VERSION_11
    }
    kotlinOptions {
        jvmTarget = '11'
    }

    //过滤编译
    variantFilter { variant ->
//        def names = variant.flavors*.name
        def isReleaseBuildType = variant.buildType.name == "release"
        if (isReleaseBuildType) {
            setIgnore(true)
        }
    }

    //不同编译类型的资源合并
    /*   All source code in the java/ directories are compiled together to generate a single output.
         Note: For a given build variant, Gradle throws a build error if it encounters two or more source set directories that have defined the same Java class.
          For example, when building a debug app, you cannot define both src/debug/Utility.java and src/main/Utility.java.
           This is because Gradle looks at both these directories during the build process and throws a "duplicate class" error.
            If you want different versions of Utility.java for different build types,
             you can have each build type define its own version of the file and not include it in the main/ source set.

       Manifests are merged together into a single manifest. Priority is given in the same order as the list above. That is,
        manifest settings for a build type override the manifest settings for a product flavor, and so on. To learn more, read about manifest merging.
       Similarly, files in the values/ directories are merged together. If two files share the same name, such as two strings.xml files,
       priority is given in the same order as the list above. That is,
       values defined in a file in the build type source set override the values defined in the same file in a product flavor, and so on.
       Resources in the res/ and asset/ directories are packaged together. If there are resources with the same name defined in two or more source sets,
        priority is given in the same order as the list above.
       Finally, Gradle gives resources and manifests included with library module dependencies the lowest priority when building the app.*/

    sourceSets {
        // Encapsulates configurations for the main source set.
        main {
            // Changes the directory for Java sources. The default directory is
            // 'src/main/java'.
            java.srcDirs = ['other/java', 'src/main/java']

            // If you list multiple directories, Gradle uses all of them to collect
            // sources. Because Gradle gives these directories equal priority, if
            // you define the same resource in more than one directory, you get an
            // error when merging resources. The default directory is 'src/main/res'.
            res.srcDirs = ['other/res1', 'other/res2', 'src/main/res']

            // Note: You should avoid specifying a directory which is a parent to one
            // or more other directories you specify. For example, avoid the following:
            // res.srcDirs = ['other/res1', 'other/res1/layouts', 'other/res1/strings']
            // You should specify either only the root 'other/res1' directory, or only the
            // nested 'other/res1/layouts' and 'other/res1/strings' directories.

            // For each source set, you can specify only one Android manifest.
            // By default, Android Studio creates a manifest for your main source
            // set in the src/main/ directory.
//            manifest.srcFile 'other/AndroidManifest.xml'
        }
    }
}
//
//configurations.all {
//    resolutionStrategy.eachDependency { DependencyResolveDetails details ->
//        if (details.requested.group == 'org.software' && details.requested.name == 'some-library' && details.requested.version == '1.2') {
//            details.useVersion '1.2.1'
//            details.because 'fixes critical bug in 1.2'
//        }
//    }
//}


dependencies {
    //强制版本依赖，并且是传递约束，子module也会被约束
    constraints {
        implementation 'androidx.core:core-ktx:1.6.0'
    }
}

dependencies {
    implementation project(":common")
//    implementation "com.android.tools.build:gradle:7.4.2"
    gradleApi()
    implementation "org.jetbrains.kotlin:kotlin-gradle-plugin-api:1.8.0"


    //如果在其他地方使用了constraints，那么这个地方就不用声明版本
//    implementation 'androidx.core:core-ktx'
//    implementation(libs.core.ktx)
    implementation(libs.bundles.ktx)
    implementation(libs.constraintlayout)
    testImplementation('junit:junit:4.13.2') {
        //失效
//        force = true
    }
    androidTestImplementation 'androidx.test.ext:junit:1.1.4'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.0'

    //版本管理
    // 1:版本号后面的!!表示strict约束，表示版本锁定
    //2:[1.7,1.8],[表示左包含，]表示左不包含，]表示右包含，[表示右不包含
    //3:strictly不能超过范围，并且覆盖传递依赖的范围 require 可以通过仲裁选择更高的版本，但是不能低于声明的版本
    // prefer 表示优先选择版本，当其他依赖中没有其他条件决定版本时候这个就是默认版本
//    implementation 'com.google.android.material:material:1.4.0!!'
    implementation("com.google.android.material:material") {
        version {
//            strictly("1.4.0")
//            strictly("]1.2, 1.7[")
            prefer("1.8.0")
//            require("1.7.25")
        }
    }
//
//    implementation("com.squareup.okhttp3:okhttp:4.9.1") {
//        //排除依赖
//        exclude group: "com.squareup.okio", module: "okio"
//    }
}

//abstract class GetGitShaTask extends DefaultTask {
//    @OutputFile
//    abstract RegularFileProperty getOutputFile()
//
//    @Inject
//    abstract ExecOperations getExecOperations()
//
//    @TaskAction
//    void process() {
//        def stdout = new ByteArrayOutputStream()
//        getExecOperations().exec {
//            it.commandLine("git", "rev-parse", "HEAD")
//            standardOutput = stdout
//        }
//        getOutputFile().get().asFile.write(stdout.toString())
//    }
//}

//project.tasks.register("myTask", GetGitShaTask) {
//    getOutputFile().set(project.layout.buildDirectory.file("sha.txt"))
//}

androidComponents {

}